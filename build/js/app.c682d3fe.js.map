{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/Solver.js","webpack:///./src/scripts/Maze.js","webpack:///./src/scripts/index.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","Direction","freeze","WALL","WAY","START","END","UP","DOWN","LEFT","RIGHT","UP_FOUND","DOWN_FOUND","LEFT_FOUND","RIGHT_FOUND","Solver","labirynth_mask","start","end","cv","copyMakeBorder","BORDER_CONSTANT","setLabirynth","y","x","cols","getLabirynth","ucharAt","path","queue","find","index","error","console","log","shortest_index","is_solved","printError","err","isNaN","exceptionFromPtr","msg","ptr","Number","split","Error","stack","replace","Maze","video","this","context_labirynth","document","getElementById","getContext","context_green_points","context_solved_path","frame_from_video","Mat","zeros","offsetHeight","offsetWidth","CV_8UC4","CV_8UC1","circles","solved_path_mask","FPS","sensivity_of_geeting_labirynth","lower_green","upper_green","green","path_color","points_mask","contours","MatVector","hierarchy","findContours","RETR_CCOMP","CHAIN_APPROX_SIMPLE","delete","positions","size","largestRadius1","largestRadius2","areaValue","contourArea","rect","boundingRect","Math","round","width","height","radius","max","gray","cvtColor","COLOR_RGBA2GRAY","threshold","THRESH_BINARY_INV","dilate","ones","CV_8U","Point","morphologyDefaultBorderValue","hsv","COLOR_BGR2HSV","low","rows","type","high","inRange","mask","subtract","points","find_position_of_end_points","is_green_points","circle","solver_result","solve","isContinuous","point","ch","channels","cap","VideoCapture","setTimeout","mazing","begin","Date","now","read","calculateMaze","clearRect","imshow","delay","onload","navigator","mediaDevices","enumerateDevices","availableCameras","then","devices","forEach","device","kind","deviceId","innerHTML","catch","message","constraints","audio","exact","getUserMedia","stream","srcObject","play","addEventListener","cnv","style","el","classList"],"mappings":"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","file":"js/app.c682d3fe.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([107,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","// TODO should be symbols: when refactoring image to labirynth it should check eg. if it is 255 and then declare this as Symbol(\"255\")\nconst Direction = Object.freeze({\n    WALL: 255,\n    WAY: 0,\n\n    START: 1,\n    END: 2,\n\n    UP: 3,\n    DOWN: 4,\n    LEFT: 5,\n    RIGHT: 6,\n\n    UP_FOUND: 7,\n    DOWN_FOUND: 8,\n    LEFT_FOUND: 9,\n    RIGHT_FOUND: 10,\n});\n\nexport default class Solver {\n\n    static solve(labirynth_mask, start, end) {\n        cv.copyMakeBorder(labirynth_mask, labirynth_mask, 1, 1, 1, 1, cv.BORDER_CONSTANT, [255, 255, 255, 255]);\n\n        const setLabirynth = (y, x, value) => {\n            labirynth_mask.data[y * labirynth_mask.cols + x] = value;\n        };\n\n        const getLabirynth = (y, x) => labirynth_mask.ucharAt(y, x);\n\n        let path = [];\n\n        path.push(start);\n        path.push(end);\n\n        setLabirynth(start.y, start.x, Direction.START);\n\n        let queue = [];\n\n        queue.push(start);\n\n        let find = false;\n\n        while (queue.length !== 0) {\n            let index = queue.shift(); //popleft\n\n            if (index.x === end.x && index.y === end.y) {\n                find = true;\n                break;\n            }\n\n            try {\n\n                if (getLabirynth(index.y, index.x - 1) == Direction.WAY) {\n                    setLabirynth(index.y, index.x - 1, Direction.RIGHT);\n                    queue.push({\n                        y: index.y,\n                        x: index.x - 1,\n                    });\n                }\n\n                if (getLabirynth(index.y, index.x + 1) == Direction.WAY) {\n                    setLabirynth(index.y, index.x + 1, Direction.LEFT);\n                    queue.push({\n                        y: index.y,\n                        x: index.x + 1,\n                    });\n                }\n\n                if (getLabirynth(index.y - 1, index.x) == Direction.WAY) {\n                    setLabirynth(index.y - 1, index.x, Direction.DOWN);\n                    queue.push({\n                        y: index.y - 1,\n                        x: index.x,\n                    });\n                }\n\n                if (getLabirynth(index.y + 1, index.x) == Direction.WAY) {\n                    setLabirynth(index.y + 1, index.x, Direction.UP);\n                    queue.push({\n                        y: index.y + 1,\n                        x: index.x,\n                    });\n                }\n\n            } catch (error) {\n                console.log(error);\n            }\n        }\n\n        let shortest_index = end;\n\n        if (find) {\n            try {\n                while (getLabirynth(shortest_index.y, shortest_index.x) != Direction.START) {\n\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.UP) {\n                        path.push(shortest_index);\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.UP_FOUND);\n                        shortest_index = {\n                            x: shortest_index.x,\n                            y: shortest_index.y - 1,\n                        };\n                    }\n\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.DOWN) {\n                        path.push(shortest_index);\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.DOWN_FOUND);\n                        shortest_index = {\n                            x: shortest_index.x,\n                            y: shortest_index.y + 1,\n                        };\n                    }\n\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.LEFT) {\n                        path.push(shortest_index);\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.LEFT_FOUND);\n                        shortest_index = {\n                            x: shortest_index.x - 1,\n                            y: shortest_index.y,\n                        };\n                    }\n\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.RIGHT) {\n                        path.push(shortest_index);\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.RIGHT_FOUND);\n                        shortest_index = {\n                            x: shortest_index.x + 1,\n                            y: shortest_index.y,\n                        };\n                    }\n                }\n\n            } catch (error) {\n                console.log(error);\n            }\n        }\n\n        return {\n            is_solved: find,\n            path: path,\n        };\n    }\n}","import Solver from \"./Solver\";\n\n\nconst printError = (err) => {\n    if (typeof err === 'undefined') {\n        err = '';\n    } else if (typeof err === 'number') {\n        if (!isNaN(err)) {\n            if (typeof cv !== 'undefined') {\n                err = 'Exception: ' + cv.exceptionFromPtr(err).msg;\n            }\n        }\n    } else if (typeof err === 'string') {\n        let ptr = Number(err.split(' ')[0]);\n        if (!isNaN(ptr)) {\n            if (typeof cv !== 'undefined') {\n                err = 'Exception: ' + cv.exceptionFromPtr(ptr).msg;\n            }\n        }\n    } else if (err instanceof Error) {\n        err = err.stack.replace(/\\n/g, '<br>');\n    }\n\n    throw new Error(err);\n};\n\n\n//TODO: dilatate should be function \nexport default class Maze {\n\n    constructor(video) {\n\n        this.video = video;\n        // this.context = document.getElementById(\"canvas_output\").getContext(\"2d\");\n        this.context_labirynth = document.getElementById(\"canvas_output_labirynth\").getContext(\"2d\");\n        this.context_green_points = document.getElementById(\"canvas_output_green_points\").getContext(\"2d\");\n        this.context_solved_path = document.getElementById(\"canvas_output_solved_path\").getContext(\"2d\");\n        this.frame_from_video = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\n\n        this.labirynth_mask = new cv.Mat(video.offsetHeight, video.offsetWidth, cv.CV_8UC1);\n\n        this.circles = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\n        this.solved_path_mask = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\n\n        this.FPS = 1;\n        this.sensivity_of_geeting_labirynth = 110;\n\n        // this.lower_green = [40, 100, 85, 0];\n        // this.upper_green = [75, 255, 255, 255];\n        this.lower_green = [30, 80, 75, 0];\n        this.upper_green = [85, 255, 255, 255];\n\n        this.green = [0, 255, 0, 128];\n        this.path_color=[214, 6, 214, 255];\n    }\n\n    // we should find position of end points\n    // there could be a lot of green elements on frame\n    // so we should find two the biggest\n    // returns position of start and end and diameter of found point\n    // returns empty array [] if there is no two points\n    find_position_of_end_points(points_mask) {\n        let contours = new cv.MatVector();\n        let hierarchy = new cv.Mat();\n\n        cv.findContours(points_mask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);\n\n        hierarchy.delete();\n\n        let positions = [];\n        // get two biggest 2\n        if (contours.size() >= 2) {\n            let largestRadius1 = 0;\n            let largestRadius2 = 0;\n\n            for (let i = 0; i < contours.size(); i++) {\n                let areaValue = cv.contourArea(contours.get(i), false);\n\n                if (areaValue > largestRadius1) {\n                    largestRadius2 = largestRadius1;\n                    largestRadius1 = areaValue;\n\n                    let rect = cv.boundingRect(contours.get(i));\n\n                    positions[1] = positions[0];\n                    positions[0] = {\n                        x: Math.round((rect.x + rect.width / 2)),\n                        y: Math.round((rect.y + rect.height / 2)),\n                        radius: Math.round(Math.max(rect.height, rect.width) / 2),\n                    };\n\n                } else if (areaValue > largestRadius2) {\n                    largestRadius2 = areaValue;\n\n                    let rect = cv.boundingRect(contours.get(i));\n\n                    positions[1] = {\n                        x: Math.round((rect.x + rect.width / 2)),\n                        y: Math.round((rect.y + rect.height / 2)),\n                        radius: Math.round(Math.max(rect.height, rect.width) / 2),\n                    };\n                }\n            }\n        }\n\n        contours.delete();\n        return positions;\n    }\n\n    calculateMaze() {\n\n        try {\n            // get grame frame\n            let gray = new cv.Mat();\n\n            cv.cvtColor(this.frame_from_video, gray, cv.COLOR_RGBA2GRAY, 0);\n            // threshold image to emilinate white colors - we get only black labirynth + green points\n            cv.threshold(gray, gray, this.sensivity_of_geeting_labirynth, 255, cv.THRESH_BINARY_INV);\n\n            // dilatation for bolder walls of maze\n            cv.dilate(\n                gray,\n                this.labirynth_mask,\n                cv.Mat.ones(3, 3, cv.CV_8U), //kernel\n                new cv.Point(-1, -1), //anchor (-1 is default for center)\n                1, // iteration of dilatation //TODO this could be too much - change also in green points in case of\n                cv.BORDER_CONSTANT,\n                cv.morphologyDefaultBorderValue()\n            );\n\n            // we need to get green points mask for differentiation of labirynth mask\n            let hsv = new cv.Mat();\n            cv.cvtColor(this.frame_from_video, hsv, cv.COLOR_BGR2HSV, 0);\n            const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), this.lower_green);\n            const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), this.upper_green);\n\n            let points_mask = new cv.Mat();\n            cv.inRange(hsv, low, high, points_mask);\n            cv.dilate(\n                points_mask,\n                points_mask,\n                cv.Mat.ones(5, 5, cv.CV_8U),\n                new cv.Point(-1, -1),\n                1,\n                cv.BORDER_CONSTANT,\n                cv.morphologyDefaultBorderValue()\n            );\n\n            let mask = new cv.Mat();\n            cv.subtract(this.labirynth_mask, points_mask, this.labirynth_mask, mask, -1);\n\n            let points = this.find_position_of_end_points(points_mask);\n\n            this.circles = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\n            this.solved_path_mask = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\n\n            if (points.length > 0) {\n                this.is_green_points = true;\n\n               //console.log(\"green points!\");\n\n                cv.circle(this.circles, new cv.Point(points[0].x, points[0].y), points[0].radius * 2, this.green, -1);\n                cv.circle(this.circles, new cv.Point(points[1].x, points[1].y), points[1].radius * 2, this.green, -1);\n\n                let solver_result = Solver.solve(this.labirynth_mask, points[0], points[1]);\n\n\n                if (solver_result.is_solved) {\n                    //console.log(\"solved!\");\n                    if (this.labirynth_mask.isContinuous()) {\n\n                        for (const point of solver_result.path) {\n                            let ch = this.solved_path_mask.channels();\n                            let ptr = point.y * this.solved_path_mask.cols * ch + point.x * ch;\n                            this.solved_path_mask.data[ptr] = this.path_color[0]; // R\n                            this.solved_path_mask.data[ptr + 1] = this.path_color[1]; // G\n                            this.solved_path_mask.data[ptr + 2] = this.path_color[2]; // B\n                            this.solved_path_mask.data[ptr + 3] = this.path_color[3]; // A\n                        }\n\n                        cv.dilate(\n                            this.solved_path_mask,\n                            this.solved_path_mask,\n                            cv.Mat.ones(4, 4, cv.CV_8U),\n                            new cv.Point(-1, -1),\n                            1,\n                            cv.BORDER_CONSTANT,\n                            cv.morphologyDefaultBorderValue()\n                        );\n\n                        // this.solved_path_mask = temp_solved_path_mask.clone();\n                        // temp_solved_path_mask.delete();\n                    }\n                }\n            }\n\n            else {\n                this.is_green_points = false;\n            }\n\n            gray.delete();\n            mask.delete();\n            low.delete();\n            high.delete();\n            hsv.delete();\n            points_mask.delete();\n\n        } catch (error) {\n            console.log(error);\n            printError(error);\n        }\n    }\n\n    start() {\n        const cap = new cv.VideoCapture(this.video);\n\n        const mazing = () => {\n            try {\n                let begin = Date.now();\n\n                cap.read(this.frame_from_video);\n\n                this.calculateMaze();\n                this.context_green_points.clearRect(0, 0, this.video.offsetHeight, this.video.offsetWidth);\n                cv.imshow('canvas_output_green_points', this.circles);\n                this.context_solved_path.clearRect(0, 0, this.video.offsetHeight, this.video.offsetWidth);\n                cv.imshow('canvas_output_solved_path', this.solved_path_mask);\n\n                let delay = 1000 / this.FPS - (Date.now() - begin);\n                setTimeout(() => mazing(), delay);\n\n            } catch (err) {\n                console.log(err);\n                printError(err);\n            }\n        };\n\n        // schedule the first one.\n        setTimeout(() => mazing(), 0); // TODO simply mazing() ?\n\n\n\n\n\n    }\n\n    //todo\n    // free(){\n    //     clearInterval(refreshIntervalId);\n    //     clearInterval(refreshIntervalId);\n    // src.delete(); dst.delete(); //TODO delete also class Mat\n    // }\n\n\n}\n","import '../styles/index.scss';\nimport Maze from './Maze.js';\n\n\n\ndocument.getElementById('opencv').onload = () => {\n    cv['onRuntimeInitialized'] = () => {\n\n\n        let video = document.getElementById(\"video_input\");\n\n\n\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n            console.log(\"enumerateDevices() not supported.\"); //TODO should be bug\n            return;\n        }\n\n        // List cameras and microphones.\n\n        let availableCameras = [];\n\n        navigator.mediaDevices.enumerateDevices()\n            .then((devices) => {\n                devices.forEach((device) => {\n                    if (device.kind == 'videoinput') {\n                        availableCameras.push(device.deviceId);\n                    }\n                });\n\n\n                document.getElementById('status').innerHTML = \"\";\n\n                for (const c of availableCameras) {\n                    document.getElementById('status').innerHTML = c + document.getElementById('status').innerHTML;\n                }\n\n            })\n            .catch((err) => {\n                console.log(err.name + \": \" + err.message);\n            });\n\n\n\n\n\n\n        var constraints = {\n            audio: false,\n            // video: true,\n            video: {\n                deviceId: {\n                    exact: availableCameras[0]\n                }\n            }\n        };\n        // var video = document.querySelector(\"video\");\n\n        function successCallback(stream) {\n            video.srcObject = stream;\n            video.play();\n\n\n\n            video.addEventListener('canplaythrough', () => {\n\n                const cnvs = [\n                    'video_input',\n                    'canvas_output_labirynth',\n                    'canvas_output_solved_path',\n                    'canvas_output_green_points'\n                ];\n\n                for (const cnv of cnvs) {\n                    document.getElementById(cnv).width = video.offsetWidth;\n                    document.getElementById(cnv).height = video.offsetHeight;\n                }\n\n                document.getElementById('container').style.width = video.offsetWidth + \"px\";\n                document.getElementById('container').style.height = video.offsetHeight + \"px\";\n\n                document.getElementById('panel').style.width = video.offsetWidth + \"px\";\n\n                const gui = [\n                    'container',\n                    'loading',\n                    'panel'\n                ];\n\n                for (const el of gui) {\n                    document.getElementById(el).classList += \" loaded\";\n                }\n\n\n\n\n                const maze = new Maze(video);\n                maze.start();\n            });\n        }\n\n        function errorCallback(error) {\n            console.log(\"navigator.getUserMedia error: \", error);\n        }\n\n        if (!navigator.mediaDevices) {\n\n            document.getElementById('status').innerHTML = \"navigator.mediaDevices is undefined\";\n        }\n\n        navigator.mediaDevices.getUserMedia(constraints)\n            .then(successCallback)\n            .catch(errorCallback);\n\n\n    };\n};"],"sourceRoot":""}