{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/scripts/Solver.js","webpack:///./src/scripts/Maze.js","webpack:///./src/scripts/index.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","0","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","Direction","freeze","WALL","WAY","START","END","UP","DOWN","LEFT","RIGHT","UP_FOUND","DOWN_FOUND","LEFT_FOUND","RIGHT_FOUND","Solver","labirynth_mask","start","end","cv","copyMakeBorder","BORDER_CONSTANT","setLabirynth","y","x","cols","getLabirynth","ucharAt","path","queue","find","index","error","console","log","shortest_index","is_solved","printError","err","isNaN","exceptionFromPtr","msg","ptr","Number","split","Error","stack","replace","Maze","video","this","context_labirynth","document","getElementById","getContext","context_green_points","context_solved_path","frame_from_video","Mat","zeros","offsetHeight","offsetWidth","CV_8UC4","CV_8UC1","circles","solved_path_mask","FPS","sensivity_of_geeting_labirynth","lower_green","upper_green","green","path_color","points_mask","contours","MatVector","hierarchy","findContours","RETR_CCOMP","CHAIN_APPROX_SIMPLE","delete","positions","size","largestRadius1","largestRadius2","areaValue","contourArea","rect","boundingRect","Math","round","width","height","radius","max","gray","cvtColor","COLOR_RGBA2GRAY","threshold","THRESH_BINARY_INV","dilate","ones","CV_8U","Point","morphologyDefaultBorderValue","hsv","COLOR_BGR2HSV","low","rows","type","high","inRange","mask","subtract","points","find_position_of_end_points","is_green_points","circle","solver_result","solve","isContinuous","point","ch","channels","cap","VideoCapture","setTimeout","mazing","begin","Date","now","read","calculateMaze","clearRect","imshow","delay","onload","navigator","mediaDevices","enumerateDevices","actualStream","availableCameras","actualCameraIndex","then","devices","forEach","device","kind","deviceId","addEventListener","getTracks","track","stop","getUserMedia","constraints","successCallback","catch","errorCallback","innerHTML","message","audio","exact","stream","srcObject","play","cnv","style","el","classList"],"mappings":"aACE,SAASA,EAAqBC,GAQ7B,IAPA,IAMIC,EAAUC,EANVC,EAAWH,EAAK,GAChBI,EAAcJ,EAAK,GACnBK,EAAiBL,EAAK,GAIHM,EAAI,EAAGC,EAAW,GACpCD,EAAIH,EAASK,OAAQF,IACzBJ,EAAUC,EAASG,GAChBG,OAAOC,UAAUC,eAAeC,KAAKC,EAAiBX,IAAYW,EAAgBX,IACpFK,EAASO,KAAKD,EAAgBX,GAAS,IAExCW,EAAgBX,GAAW,EAE5B,IAAID,KAAYG,EACZK,OAAOC,UAAUC,eAAeC,KAAKR,EAAaH,KACpDc,EAAQd,GAAYG,EAAYH,IAKlC,IAFGe,GAAqBA,EAAoBhB,GAEtCO,EAASC,QACdD,EAASU,OAATV,GAOD,OAHAW,EAAgBJ,KAAKK,MAAMD,EAAiBb,GAAkB,IAGvDe,IAER,SAASA,IAER,IADA,IAAIC,EACIf,EAAI,EAAGA,EAAIY,EAAgBV,OAAQF,IAAK,CAG/C,IAFA,IAAIgB,EAAiBJ,EAAgBZ,GACjCiB,GAAY,EACRC,EAAI,EAAGA,EAAIF,EAAed,OAAQgB,IAAK,CAC9C,IAAIC,EAAQH,EAAeE,GACG,IAA3BX,EAAgBY,KAAcF,GAAY,GAE3CA,IACFL,EAAgBQ,OAAOpB,IAAK,GAC5Be,EAASM,EAAoBA,EAAoBC,EAAIN,EAAe,KAItE,OAAOD,EAIR,IAAIQ,EAAmB,GAKnBhB,EAAkB,CACrBiB,EAAG,GAGAZ,EAAkB,GAGtB,SAASS,EAAoB1B,GAG5B,GAAG4B,EAAiB5B,GACnB,OAAO4B,EAAiB5B,GAAU8B,QAGnC,IAAIC,EAASH,EAAiB5B,GAAY,CACzCK,EAAGL,EACHgC,GAAG,EACHF,QAAS,IAUV,OANAhB,EAAQd,GAAUW,KAAKoB,EAAOD,QAASC,EAAQA,EAAOD,QAASJ,GAG/DK,EAAOC,GAAI,EAGJD,EAAOD,QAKfJ,EAAoBO,EAAInB,EAGxBY,EAAoBQ,EAAIN,EAGxBF,EAAoBS,EAAI,SAASL,EAASM,EAAMC,GAC3CX,EAAoBY,EAAER,EAASM,IAClC5B,OAAO+B,eAAeT,EAASM,EAAM,CAAEI,YAAY,EAAMC,IAAKJ,KAKhEX,EAAoBgB,EAAI,SAASZ,GACX,oBAAXa,QAA0BA,OAAOC,aAC1CpC,OAAO+B,eAAeT,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DrC,OAAO+B,eAAeT,EAAS,aAAc,CAAEe,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKzC,OAAO0C,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBzC,OAAO+B,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBS,EAAEc,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAStB,GAChC,IAAIM,EAASN,GAAUA,EAAOiB,WAC7B,WAAwB,OAAOjB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAL,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASgB,EAAQC,GAAY,OAAO/C,OAAOC,UAAUC,eAAeC,KAAK2C,EAAQC,IAGzG7B,EAAoB8B,EAAI,GAExB,IAAIC,EAAaC,OAAqB,aAAIA,OAAqB,cAAK,GAChEC,EAAmBF,EAAW5C,KAAKuC,KAAKK,GAC5CA,EAAW5C,KAAOf,EAClB2D,EAAaA,EAAWG,QACxB,IAAI,IAAIvD,EAAI,EAAGA,EAAIoD,EAAWlD,OAAQF,IAAKP,EAAqB2D,EAAWpD,IAC3E,IAAIU,EAAsB4C,EAI1B1C,EAAgBJ,KAAK,CAAC,IAAI,IAEnBM,I,0UCtJT,IAAM0C,EAAYrD,OAAOsD,OAAO,CAC5BC,KAAM,IACNC,IAAK,EAELC,MAAO,EACPC,IAAK,EAELC,GAAI,EACJC,KAAM,EACNC,KAAM,EACNC,MAAO,EAEPC,SAAU,EACVC,WAAY,EACZC,WAAY,EACZC,YAAa,KAGIC,E,kLAEJC,EAAgBC,EAAOC,GAChCC,GAAGC,eAAeJ,EAAgBA,EAAgB,EAAG,EAAG,EAAG,EAAGG,GAAGE,gBAAiB,CAAC,IAAK,IAAK,IAAK,MAElG,IAAMC,EAAe,SAACC,EAAGC,EAAGvC,GACxB+B,EAAe7E,KAAKoF,EAAIP,EAAeS,KAAOD,GAAKvC,GAGjDyC,EAAe,SAACH,EAAGC,GAAJ,OAAUR,EAAeW,QAAQJ,EAAGC,IAErDI,EAAO,GAEXA,EAAK3E,KAAKgE,GACVW,EAAK3E,KAAKiE,GAEVI,EAAaL,EAAMM,EAAGN,EAAMO,EAAGvB,EAAUI,OAEzC,IAAIwB,EAAQ,GAEZA,EAAM5E,KAAKgE,GAIX,IAFA,IAAIa,GAAO,EAEa,IAAjBD,EAAMlF,QAAc,CACvB,IAAIoF,EAAQF,EAAMzE,QAElB,GAAI2E,EAAMP,IAAMN,EAAIM,GAAKO,EAAMR,IAAML,EAAIK,EAAG,CACxCO,GAAO,EACP,MAGJ,IAEQJ,EAAaK,EAAMR,EAAGQ,EAAMP,EAAI,IAAMvB,EAAUG,MAChDkB,EAAaS,EAAMR,EAAGQ,EAAMP,EAAI,EAAGvB,EAAUS,OAC7CmB,EAAM5E,KAAK,CACPsE,EAAGQ,EAAMR,EACTC,EAAGO,EAAMP,EAAI,KAIjBE,EAAaK,EAAMR,EAAGQ,EAAMP,EAAI,IAAMvB,EAAUG,MAChDkB,EAAaS,EAAMR,EAAGQ,EAAMP,EAAI,EAAGvB,EAAUQ,MAC7CoB,EAAM5E,KAAK,CACPsE,EAAGQ,EAAMR,EACTC,EAAGO,EAAMP,EAAI,KAIjBE,EAAaK,EAAMR,EAAI,EAAGQ,EAAMP,IAAMvB,EAAUG,MAChDkB,EAAaS,EAAMR,EAAI,EAAGQ,EAAMP,EAAGvB,EAAUO,MAC7CqB,EAAM5E,KAAK,CACPsE,EAAGQ,EAAMR,EAAI,EACbC,EAAGO,EAAMP,KAIbE,EAAaK,EAAMR,EAAI,EAAGQ,EAAMP,IAAMvB,EAAUG,MAChDkB,EAAaS,EAAMR,EAAI,EAAGQ,EAAMP,EAAGvB,EAAUM,IAC7CsB,EAAM5E,KAAK,CACPsE,EAAGQ,EAAMR,EAAI,EACbC,EAAGO,EAAMP,KAInB,MAAOQ,GACLC,QAAQC,IAAIF,IAIpB,IAAIG,EAAiBjB,EAErB,GAAIY,EACA,IACI,KAAOJ,EAAaS,EAAeZ,EAAGY,EAAeX,IAAMvB,EAAUI,OAE7DqB,EAAaS,EAAeZ,EAAGY,EAAeX,IAAMvB,EAAUM,KAC9DqB,EAAK3E,KAAKkF,GACVb,EAAaa,EAAeZ,EAAGY,EAAeX,EAAGvB,EAAUU,UAC3DwB,EAAiB,CACbX,EAAGW,EAAeX,EAClBD,EAAGY,EAAeZ,EAAI,IAI1BG,EAAaS,EAAeZ,EAAGY,EAAeX,IAAMvB,EAAUO,OAC9DoB,EAAK3E,KAAKkF,GACVb,EAAaa,EAAeZ,EAAGY,EAAeX,EAAGvB,EAAUW,YAC3DuB,EAAiB,CACbX,EAAGW,EAAeX,EAClBD,EAAGY,EAAeZ,EAAI,IAI1BG,EAAaS,EAAeZ,EAAGY,EAAeX,IAAMvB,EAAUQ,OAC9DmB,EAAK3E,KAAKkF,GACVb,EAAaa,EAAeZ,EAAGY,EAAeX,EAAGvB,EAAUY,YAC3DsB,EAAiB,CACbX,EAAGW,EAAeX,EAAI,EACtBD,EAAGY,EAAeZ,IAItBG,EAAaS,EAAeZ,EAAGY,EAAeX,IAAMvB,EAAUS,QAC9DkB,EAAK3E,KAAKkF,GACVb,EAAaa,EAAeZ,EAAGY,EAAeX,EAAGvB,EAAUa,aAC3DqB,EAAiB,CACbX,EAAGW,EAAeX,EAAI,EACtBD,EAAGY,EAAeZ,IAKhC,MAAOS,GACLC,QAAQC,IAAIF,GAIpB,MAAO,CACHI,UAAWN,EACXF,KAAMA,O,guCCzIlB,IAAMS,EAAa,SAACC,GAChB,QAAmB,IAARA,EACPA,EAAM,QACH,GAAmB,iBAARA,EACTC,MAAMD,IACW,oBAAPnB,KACPmB,EAAM,cAAgBnB,GAAGqB,iBAAiBF,GAAKG,UAGpD,GAAmB,iBAARH,EAAkB,CAChC,IAAII,EAAMC,OAAOL,EAAIM,MAAM,KAAK,IAC3BL,MAAMG,IACW,oBAAPvB,KACPmB,EAAM,cAAgBnB,GAAGqB,iBAAiBE,GAAKD,UAGhDH,aAAeO,QACtBP,EAAMA,EAAIQ,MAAMC,QAAQ,MAAO,SAGnC,MAAM,IAAIF,MAAMP,IAKCU,E,WAEjB,WAAYC,I,4FAAO,SAEfC,KAAKD,MAAQA,EAEbC,KAAKC,kBAAoBC,SAASC,eAAe,2BAA2BC,WAAW,MACvFJ,KAAKK,qBAAuBH,SAASC,eAAe,8BAA8BC,WAAW,MAC7FJ,KAAKM,oBAAsBJ,SAASC,eAAe,6BAA6BC,WAAW,MAC3FJ,KAAKO,iBAAmBtC,GAAGuC,IAAIC,MAAMT,KAAKD,MAAMW,aAAcV,KAAKD,MAAMY,YAAa1C,GAAG2C,SAEzFZ,KAAKlC,eAAiB,IAAIG,GAAGuC,IAAIT,EAAMW,aAAcX,EAAMY,YAAa1C,GAAG4C,SAE3Eb,KAAKc,QAAU7C,GAAGuC,IAAIC,MAAMT,KAAKD,MAAMW,aAAcV,KAAKD,MAAMY,YAAa1C,GAAG2C,SAChFZ,KAAKe,iBAAmB9C,GAAGuC,IAAIC,MAAMT,KAAKD,MAAMW,aAAcV,KAAKD,MAAMY,YAAa1C,GAAG2C,SAEzFZ,KAAKgB,IAAM,EACXhB,KAAKiB,+BAAiC,IAItCjB,KAAKkB,YAAc,CAAC,GAAI,GAAI,GAAI,GAChClB,KAAKmB,YAAc,CAAC,GAAI,IAAK,IAAK,KAElCnB,KAAKoB,MAAQ,CAAC,EAAG,IAAK,EAAG,KACzBpB,KAAKqB,WAAW,CAAC,IAAK,EAAG,IAAK,K,2EAQNC,GACxB,IAAIC,EAAW,IAAItD,GAAGuD,UAClBC,EAAY,IAAIxD,GAAGuC,IAEvBvC,GAAGyD,aAAaJ,EAAaC,EAAUE,EAAWxD,GAAG0D,WAAY1D,GAAG2D,qBAEpEH,EAAUI,SAEV,IAAIC,EAAY,GAEhB,GAAIP,EAASQ,QAAU,EAInB,IAHA,IAAIC,EAAiB,EACjBC,EAAiB,EAEZ1I,EAAI,EAAGA,EAAIgI,EAASQ,OAAQxI,IAAK,CACtC,IAAI2I,EAAYjE,GAAGkE,YAAYZ,EAAS5F,IAAIpC,IAAI,GAEhD,GAAI2I,EAAYF,EAAgB,CAC5BC,EAAiBD,EACjBA,EAAiBE,EAEjB,IAAIE,EAAOnE,GAAGoE,aAAad,EAAS5F,IAAIpC,IAExCuI,EAAU,GAAKA,EAAU,GACzBA,EAAU,GAAK,CACXxD,EAAGgE,KAAKC,MAAOH,EAAK9D,EAAI8D,EAAKI,MAAQ,GACrCnE,EAAGiE,KAAKC,MAAOH,EAAK/D,EAAI+D,EAAKK,OAAS,GACtCC,OAAQJ,KAAKC,MAAMD,KAAKK,IAAIP,EAAKK,OAAQL,EAAKI,OAAS,SAGxD,GAAIN,EAAYD,EAAgB,CACnCA,EAAiBC,EAEjB,IAAIE,EAAOnE,GAAGoE,aAAad,EAAS5F,IAAIpC,IAExCuI,EAAU,GAAK,CACXxD,EAAGgE,KAAKC,MAAOH,EAAK9D,EAAI8D,EAAKI,MAAQ,GACrCnE,EAAGiE,KAAKC,MAAOH,EAAK/D,EAAI+D,EAAKK,OAAS,GACtCC,OAAQJ,KAAKC,MAAMD,KAAKK,IAAIP,EAAKK,OAAQL,EAAKI,OAAS,KAOvE,OADAjB,EAASM,SACFC,I,sCAKP,IAEI,IAAIc,EAAO,IAAI3E,GAAGuC,IAElBvC,GAAG4E,SAAS7C,KAAKO,iBAAkBqC,EAAM3E,GAAG6E,gBAAiB,GAE7D7E,GAAG8E,UAAUH,EAAMA,EAAM5C,KAAKiB,+BAAgC,IAAKhD,GAAG+E,mBAGtE/E,GAAGgF,OACCL,EACA5C,KAAKlC,eACLG,GAAGuC,IAAI0C,KAAK,EAAG,EAAGjF,GAAGkF,OACrB,IAAIlF,GAAGmF,OAAO,GAAI,GAClB,EACAnF,GAAGE,gBACHF,GAAGoF,gCAIP,IAAIC,EAAM,IAAIrF,GAAGuC,IACjBvC,GAAG4E,SAAS7C,KAAKO,iBAAkB+C,EAAKrF,GAAGsF,cAAe,GAC1D,IAAMC,EAAM,IAAIvF,GAAGuC,IAAI8C,EAAIG,KAAMH,EAAI/E,KAAM+E,EAAII,OAAQ1D,KAAKkB,aACtDyC,EAAO,IAAI1F,GAAGuC,IAAI8C,EAAIG,KAAMH,EAAI/E,KAAM+E,EAAII,OAAQ1D,KAAKmB,aAEzDG,EAAc,IAAIrD,GAAGuC,IACzBvC,GAAG2F,QAAQN,EAAKE,EAAKG,EAAMrC,GAC3BrD,GAAGgF,OACC3B,EACAA,EACArD,GAAGuC,IAAI0C,KAAK,EAAG,EAAGjF,GAAGkF,OACrB,IAAIlF,GAAGmF,OAAO,GAAI,GAClB,EACAnF,GAAGE,gBACHF,GAAGoF,gCAGP,IAAIQ,EAAO,IAAI5F,GAAGuC,IAClBvC,GAAG6F,SAAS9D,KAAKlC,eAAgBwD,EAAatB,KAAKlC,eAAgB+F,GAAO,GAE1E,IAAIE,EAAS/D,KAAKgE,4BAA4B1C,GAK9C,GAHAtB,KAAKc,QAAU7C,GAAGuC,IAAIC,MAAMT,KAAKD,MAAMW,aAAcV,KAAKD,MAAMY,YAAa1C,GAAG2C,SAChFZ,KAAKe,iBAAmB9C,GAAGuC,IAAIC,MAAMT,KAAKD,MAAMW,aAAcV,KAAKD,MAAMY,YAAa1C,GAAG2C,SAErFmD,EAAOtK,OAAS,EAAG,CACnBuG,KAAKiE,iBAAkB,EAIvBhG,GAAGiG,OAAOlE,KAAKc,QAAS,IAAI7C,GAAGmF,MAAMW,EAAO,GAAGzF,EAAGyF,EAAO,GAAG1F,GAAuB,EAAnB0F,EAAO,GAAGrB,OAAY1C,KAAKoB,OAAQ,GACnGnD,GAAGiG,OAAOlE,KAAKc,QAAS,IAAI7C,GAAGmF,MAAMW,EAAO,GAAGzF,EAAGyF,EAAO,GAAG1F,GAAuB,EAAnB0F,EAAO,GAAGrB,OAAY1C,KAAKoB,OAAQ,GAEnG,IAAI+C,EAAgBtG,EAAOuG,MAAMpE,KAAKlC,eAAgBiG,EAAO,GAAIA,EAAO,IAGxE,GAAII,EAAcjF,WAEVc,KAAKlC,eAAeuG,eAAgB,WAEhBF,EAAczF,MAFE,IAEpC,2BAAwC,KAA7B4F,EAA6B,QAChCC,EAAKvE,KAAKe,iBAAiByD,WAC3BhF,EAAM8E,EAAMjG,EAAI2B,KAAKe,iBAAiBxC,KAAOgG,EAAKD,EAAMhG,EAAIiG,EAChEvE,KAAKe,iBAAiB9H,KAAKuG,GAAOQ,KAAKqB,WAAW,GAClDrB,KAAKe,iBAAiB9H,KAAKuG,EAAM,GAAKQ,KAAKqB,WAAW,GACtDrB,KAAKe,iBAAiB9H,KAAKuG,EAAM,GAAKQ,KAAKqB,WAAW,GACtDrB,KAAKe,iBAAiB9H,KAAKuG,EAAM,GAAKQ,KAAKqB,WAAW,IARtB,8BAWpCpD,GAAGgF,OACCjD,KAAKe,iBACLf,KAAKe,iBACL9C,GAAGuC,IAAI0C,KAAK,EAAG,EAAGjF,GAAGkF,OACrB,IAAIlF,GAAGmF,OAAO,GAAI,GAClB,EACAnF,GAAGE,gBACHF,GAAGoF,sCAUfrD,KAAKiE,iBAAkB,EAG3BrB,EAAKf,SACLgC,EAAKhC,SACL2B,EAAI3B,SACJ8B,EAAK9B,SACLyB,EAAIzB,SACJP,EAAYO,SAEd,MAAO/C,GACLC,QAAQC,IAAIF,GACZK,EAAWL,M,8BAIX,WACE2F,EAAM,IAAIxG,GAAGyG,aAAa1E,KAAKD,OAwBrC4E,YAAW,kBAtBI,SAATC,IACF,IACI,IAAIC,EAAQC,KAAKC,MAEjBN,EAAIO,KAAK,EAAKzE,kBAEd,EAAK0E,gBACL,EAAK5E,qBAAqB6E,UAAU,EAAG,EAAG,EAAKnF,MAAMW,aAAc,EAAKX,MAAMY,aAC9E1C,GAAGkH,OAAO,6BAA8B,EAAKrE,SAC7C,EAAKR,oBAAoB4E,UAAU,EAAG,EAAG,EAAKnF,MAAMW,aAAc,EAAKX,MAAMY,aAC7E1C,GAAGkH,OAAO,4BAA6B,EAAKpE,kBAE5C,IAAIqE,EAAQ,IAAO,EAAKpE,KAAO8D,KAAKC,MAAQF,GAC5CF,YAAW,kBAAMC,MAAUQ,GAE7B,MAAOhG,GACLL,QAAQC,IAAII,GACZD,EAAWC,IAKFwF,KAAU,Q,gCCzOnC1E,SAASC,eAAe,UAAUkF,OAAS,WACvCpH,GAAE,qBAA2B,WAGzB,IAAI8B,EAAQG,SAASC,eAAe,eAIpC,GAAKmF,UAAUC,cAAiBD,UAAUC,aAAaC,iBAAvD,CAOA,IAGIC,EAHAC,EAAmB,GACnBC,EAAoB,EAMxBL,UAAUC,aAAaC,mBAClBI,MAAK,SAACC,GAGHA,EAAQC,SAAQ,SAACC,GACM,cAAfA,EAAOC,MACPN,EAAiB3L,KAAKgM,EAAOE,aAKrC/F,SAASC,eAAe,sBAAsB+F,iBAAiB,SAAS,WAChER,EAAiBjM,OAAS,IAC1BkM,EAAyC,GAArBA,EAAyB,EAAI,EAEjDF,EAAaU,YAAYL,SAAQ,SAAAM,GAC7BA,EAAMC,UAGVf,UAAUC,aAAae,aAAaC,GAC/BX,KAAKY,GACLC,MAAMC,GAEPxG,SAASC,eAAe,UAAUwG,UAAYjB,EAAiB,GAAK,QAAUA,EAAiB,IAGvG3G,QAAQC,IAAIyG,MAMhBH,UAAUC,aAAae,aAAaC,GAC/BX,KAAKY,GACLC,MAAMC,MAGdD,OAAM,SAACrH,GACJL,QAAQC,IAAII,EAAI9D,KAAO,KAAO8D,EAAIwH,YAK1C,IAAIL,EAAc,CACdM,OAAO,EACP9G,MAAO,CACHkG,SAAU,CACNa,MAAOpB,EAAiBC,MAiD/BL,UAAUC,eAEXrF,SAASC,eAAe,UAAUwG,UAAY,4CA/G9C5H,QAAQC,IAAI,qCAkEhB,SAASwH,EAAgBO,GACrBtB,EAAesB,EACfhH,EAAMiH,UAAYD,EAClBhH,EAAMkH,OAENlH,EAAMmG,iBAAiB,kBAAkB,WASrC,IAPA,IAOA,MAPa,CACT,cACA,0BACA,4BACA,8BAGJ,eAAwB,CAAnB,IAAMgB,EAAG,KACVhH,SAASC,eAAe+G,GAAK1E,MAAQzC,EAAMY,YAC3CT,SAASC,eAAe+G,GAAKzE,OAAS1C,EAAMW,aAGhDR,SAASC,eAAe,aAAagH,MAAM3E,MAAQzC,EAAMY,YAAc,KACvET,SAASC,eAAe,aAAagH,MAAM1E,OAAS1C,EAAMW,aAAe,KAEzER,SAASC,eAAe,SAASgH,MAAM3E,MAAQzC,EAAMY,YAAc,KAQnE,IANA,IAMA,MANY,CACR,YACA,UACA,SAGJ,eAAsB,CAAjB,IAAMyG,EAAE,KACTlH,SAASC,eAAeiH,GAAIC,WAAa,UAGhC,IAAIvH,EAAKC,GACjBhC,WAIb,SAAS2I,EAAc5H,GACnBC,QAAQC,IAAI,iCAAkCF,O","file":"js/app.7f77d19e.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([119,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","// TODO should be symbols: when refactoring image to labirynth it should check eg. if it is 255 and then declare this as Symbol(\"255\")\r\nconst Direction = Object.freeze({\r\n    WALL: 255,\r\n    WAY: 0,\r\n\r\n    START: 1,\r\n    END: 2,\r\n\r\n    UP: 3,\r\n    DOWN: 4,\r\n    LEFT: 5,\r\n    RIGHT: 6,\r\n\r\n    UP_FOUND: 7,\r\n    DOWN_FOUND: 8,\r\n    LEFT_FOUND: 9,\r\n    RIGHT_FOUND: 10,\r\n});\r\n\r\nexport default class Solver {\r\n\r\n    static solve(labirynth_mask, start, end) {\r\n        cv.copyMakeBorder(labirynth_mask, labirynth_mask, 1, 1, 1, 1, cv.BORDER_CONSTANT, [255, 255, 255, 255]);\r\n\r\n        const setLabirynth = (y, x, value) => {\r\n            labirynth_mask.data[y * labirynth_mask.cols + x] = value;\r\n        };\r\n\r\n        const getLabirynth = (y, x) => labirynth_mask.ucharAt(y, x);\r\n\r\n        let path = [];\r\n\r\n        path.push(start);\r\n        path.push(end);\r\n\r\n        setLabirynth(start.y, start.x, Direction.START);\r\n\r\n        let queue = [];\r\n\r\n        queue.push(start);\r\n\r\n        let find = false;\r\n\r\n        while (queue.length !== 0) {\r\n            let index = queue.shift(); //popleft\r\n\r\n            if (index.x === end.x && index.y === end.y) {\r\n                find = true;\r\n                break;\r\n            }\r\n\r\n            try {\r\n\r\n                if (getLabirynth(index.y, index.x - 1) == Direction.WAY) {\r\n                    setLabirynth(index.y, index.x - 1, Direction.RIGHT);\r\n                    queue.push({\r\n                        y: index.y,\r\n                        x: index.x - 1,\r\n                    });\r\n                }\r\n\r\n                if (getLabirynth(index.y, index.x + 1) == Direction.WAY) {\r\n                    setLabirynth(index.y, index.x + 1, Direction.LEFT);\r\n                    queue.push({\r\n                        y: index.y,\r\n                        x: index.x + 1,\r\n                    });\r\n                }\r\n\r\n                if (getLabirynth(index.y - 1, index.x) == Direction.WAY) {\r\n                    setLabirynth(index.y - 1, index.x, Direction.DOWN);\r\n                    queue.push({\r\n                        y: index.y - 1,\r\n                        x: index.x,\r\n                    });\r\n                }\r\n\r\n                if (getLabirynth(index.y + 1, index.x) == Direction.WAY) {\r\n                    setLabirynth(index.y + 1, index.x, Direction.UP);\r\n                    queue.push({\r\n                        y: index.y + 1,\r\n                        x: index.x,\r\n                    });\r\n                }\r\n\r\n            } catch (error) {\r\n                console.log(error);\r\n            }\r\n        }\r\n\r\n        let shortest_index = end;\r\n\r\n        if (find) {\r\n            try {\r\n                while (getLabirynth(shortest_index.y, shortest_index.x) != Direction.START) {\r\n\r\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.UP) {\r\n                        path.push(shortest_index);\r\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.UP_FOUND);\r\n                        shortest_index = {\r\n                            x: shortest_index.x,\r\n                            y: shortest_index.y - 1,\r\n                        };\r\n                    }\r\n\r\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.DOWN) {\r\n                        path.push(shortest_index);\r\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.DOWN_FOUND);\r\n                        shortest_index = {\r\n                            x: shortest_index.x,\r\n                            y: shortest_index.y + 1,\r\n                        };\r\n                    }\r\n\r\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.LEFT) {\r\n                        path.push(shortest_index);\r\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.LEFT_FOUND);\r\n                        shortest_index = {\r\n                            x: shortest_index.x - 1,\r\n                            y: shortest_index.y,\r\n                        };\r\n                    }\r\n\r\n                    if (getLabirynth(shortest_index.y, shortest_index.x) == Direction.RIGHT) {\r\n                        path.push(shortest_index);\r\n                        setLabirynth(shortest_index.y, shortest_index.x, Direction.RIGHT_FOUND);\r\n                        shortest_index = {\r\n                            x: shortest_index.x + 1,\r\n                            y: shortest_index.y,\r\n                        };\r\n                    }\r\n                }\r\n\r\n            } catch (error) {\r\n                console.log(error);\r\n            }\r\n        }\r\n\r\n        return {\r\n            is_solved: find,\r\n            path: path,\r\n        };\r\n    }\r\n}","import Solver from \"./Solver\";\r\n\r\n\r\nconst printError = (err) => {\r\n    if (typeof err === 'undefined') {\r\n        err = '';\r\n    } else if (typeof err === 'number') {\r\n        if (!isNaN(err)) {\r\n            if (typeof cv !== 'undefined') {\r\n                err = 'Exception: ' + cv.exceptionFromPtr(err).msg;\r\n            }\r\n        }\r\n    } else if (typeof err === 'string') {\r\n        let ptr = Number(err.split(' ')[0]);\r\n        if (!isNaN(ptr)) {\r\n            if (typeof cv !== 'undefined') {\r\n                err = 'Exception: ' + cv.exceptionFromPtr(ptr).msg;\r\n            }\r\n        }\r\n    } else if (err instanceof Error) {\r\n        err = err.stack.replace(/\\n/g, '<br>');\r\n    }\r\n\r\n    throw new Error(err);\r\n};\r\n\r\n\r\n//TODO: dilatate should be function \r\nexport default class Maze {\r\n\r\n    constructor(video) {\r\n\r\n        this.video = video;\r\n        // this.context = document.getElementById(\"canvas_output\").getContext(\"2d\");\r\n        this.context_labirynth = document.getElementById(\"canvas_output_labirynth\").getContext(\"2d\");\r\n        this.context_green_points = document.getElementById(\"canvas_output_green_points\").getContext(\"2d\");\r\n        this.context_solved_path = document.getElementById(\"canvas_output_solved_path\").getContext(\"2d\");\r\n        this.frame_from_video = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\r\n\r\n        this.labirynth_mask = new cv.Mat(video.offsetHeight, video.offsetWidth, cv.CV_8UC1);\r\n\r\n        this.circles = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\r\n        this.solved_path_mask = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\r\n\r\n        this.FPS = 1;\r\n        this.sensivity_of_geeting_labirynth = 110;\r\n\r\n        // this.lower_green = [40, 100, 85, 0];\r\n        // this.upper_green = [75, 255, 255, 255];\r\n        this.lower_green = [30, 80, 75, 0];\r\n        this.upper_green = [85, 255, 255, 255];\r\n\r\n        this.green = [0, 255, 0, 128];\r\n        this.path_color=[214, 6, 214, 255];\r\n    }\r\n\r\n    // we should find position of end points\r\n    // there could be a lot of green elements on frame\r\n    // so we should find two the biggest\r\n    // returns position of start and end and diameter of found point\r\n    // returns empty array [] if there is no two points\r\n    find_position_of_end_points(points_mask) {\r\n        let contours = new cv.MatVector();\r\n        let hierarchy = new cv.Mat();\r\n\r\n        cv.findContours(points_mask, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);\r\n\r\n        hierarchy.delete();\r\n\r\n        let positions = [];\r\n        // get two biggest 2\r\n        if (contours.size() >= 2) {\r\n            let largestRadius1 = 0;\r\n            let largestRadius2 = 0;\r\n\r\n            for (let i = 0; i < contours.size(); i++) {\r\n                let areaValue = cv.contourArea(contours.get(i), false);\r\n\r\n                if (areaValue > largestRadius1) {\r\n                    largestRadius2 = largestRadius1;\r\n                    largestRadius1 = areaValue;\r\n\r\n                    let rect = cv.boundingRect(contours.get(i));\r\n\r\n                    positions[1] = positions[0];\r\n                    positions[0] = {\r\n                        x: Math.round((rect.x + rect.width / 2)),\r\n                        y: Math.round((rect.y + rect.height / 2)),\r\n                        radius: Math.round(Math.max(rect.height, rect.width) / 2),\r\n                    };\r\n\r\n                } else if (areaValue > largestRadius2) {\r\n                    largestRadius2 = areaValue;\r\n\r\n                    let rect = cv.boundingRect(contours.get(i));\r\n\r\n                    positions[1] = {\r\n                        x: Math.round((rect.x + rect.width / 2)),\r\n                        y: Math.round((rect.y + rect.height / 2)),\r\n                        radius: Math.round(Math.max(rect.height, rect.width) / 2),\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        contours.delete();\r\n        return positions;\r\n    }\r\n\r\n    calculateMaze() {\r\n\r\n        try {\r\n            // get grame frame\r\n            let gray = new cv.Mat();\r\n\r\n            cv.cvtColor(this.frame_from_video, gray, cv.COLOR_RGBA2GRAY, 0);\r\n            // threshold image to emilinate white colors - we get only black labirynth + green points\r\n            cv.threshold(gray, gray, this.sensivity_of_geeting_labirynth, 255, cv.THRESH_BINARY_INV);\r\n\r\n            // dilatation for bolder walls of maze\r\n            cv.dilate(\r\n                gray,\r\n                this.labirynth_mask,\r\n                cv.Mat.ones(3, 3, cv.CV_8U), //kernel\r\n                new cv.Point(-1, -1), //anchor (-1 is default for center)\r\n                1, // iteration of dilatation //TODO this could be too much - change also in green points in case of\r\n                cv.BORDER_CONSTANT,\r\n                cv.morphologyDefaultBorderValue()\r\n            );\r\n\r\n            // we need to get green points mask for differentiation of labirynth mask\r\n            let hsv = new cv.Mat();\r\n            cv.cvtColor(this.frame_from_video, hsv, cv.COLOR_BGR2HSV, 0);\r\n            const low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), this.lower_green);\r\n            const high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), this.upper_green);\r\n\r\n            let points_mask = new cv.Mat();\r\n            cv.inRange(hsv, low, high, points_mask);\r\n            cv.dilate(\r\n                points_mask,\r\n                points_mask,\r\n                cv.Mat.ones(5, 5, cv.CV_8U),\r\n                new cv.Point(-1, -1),\r\n                1,\r\n                cv.BORDER_CONSTANT,\r\n                cv.morphologyDefaultBorderValue()\r\n            );\r\n\r\n            let mask = new cv.Mat();\r\n            cv.subtract(this.labirynth_mask, points_mask, this.labirynth_mask, mask, -1);\r\n\r\n            let points = this.find_position_of_end_points(points_mask);\r\n\r\n            this.circles = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\r\n            this.solved_path_mask = cv.Mat.zeros(this.video.offsetHeight, this.video.offsetWidth, cv.CV_8UC4);\r\n\r\n            if (points.length > 0) {\r\n                this.is_green_points = true;\r\n\r\n               //console.log(\"green points!\");\r\n\r\n                cv.circle(this.circles, new cv.Point(points[0].x, points[0].y), points[0].radius * 2, this.green, -1);\r\n                cv.circle(this.circles, new cv.Point(points[1].x, points[1].y), points[1].radius * 2, this.green, -1);\r\n\r\n                let solver_result = Solver.solve(this.labirynth_mask, points[0], points[1]);\r\n\r\n\r\n                if (solver_result.is_solved) {\r\n                    //console.log(\"solved!\");\r\n                    if (this.labirynth_mask.isContinuous()) {\r\n\r\n                        for (const point of solver_result.path) {\r\n                            let ch = this.solved_path_mask.channels();\r\n                            let ptr = point.y * this.solved_path_mask.cols * ch + point.x * ch;\r\n                            this.solved_path_mask.data[ptr] = this.path_color[0]; // R\r\n                            this.solved_path_mask.data[ptr + 1] = this.path_color[1]; // G\r\n                            this.solved_path_mask.data[ptr + 2] = this.path_color[2]; // B\r\n                            this.solved_path_mask.data[ptr + 3] = this.path_color[3]; // A\r\n                        }\r\n\r\n                        cv.dilate(\r\n                            this.solved_path_mask,\r\n                            this.solved_path_mask,\r\n                            cv.Mat.ones(4, 4, cv.CV_8U),\r\n                            new cv.Point(-1, -1),\r\n                            1,\r\n                            cv.BORDER_CONSTANT,\r\n                            cv.morphologyDefaultBorderValue()\r\n                        );\r\n\r\n                        // this.solved_path_mask = temp_solved_path_mask.clone();\r\n                        // temp_solved_path_mask.delete();\r\n                    }\r\n                }\r\n            }\r\n\r\n            else {\r\n                this.is_green_points = false;\r\n            }\r\n\r\n            gray.delete();\r\n            mask.delete();\r\n            low.delete();\r\n            high.delete();\r\n            hsv.delete();\r\n            points_mask.delete();\r\n\r\n        } catch (error) {\r\n            console.log(error);\r\n            printError(error);\r\n        }\r\n    }\r\n\r\n    start() {\r\n        const cap = new cv.VideoCapture(this.video);\r\n\r\n        const mazing = () => {\r\n            try {\r\n                let begin = Date.now();\r\n\r\n                cap.read(this.frame_from_video);\r\n\r\n                this.calculateMaze();\r\n                this.context_green_points.clearRect(0, 0, this.video.offsetHeight, this.video.offsetWidth);\r\n                cv.imshow('canvas_output_green_points', this.circles);\r\n                this.context_solved_path.clearRect(0, 0, this.video.offsetHeight, this.video.offsetWidth);\r\n                cv.imshow('canvas_output_solved_path', this.solved_path_mask);\r\n\r\n                let delay = 1000 / this.FPS - (Date.now() - begin);\r\n                setTimeout(() => mazing(), delay);\r\n\r\n            } catch (err) {\r\n                console.log(err);\r\n                printError(err);\r\n            }\r\n        };\r\n\r\n        // schedule the first one.\r\n        setTimeout(() => mazing(), 0); // TODO simply mazing() ?\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    //todo\r\n    // free(){\r\n    //     clearInterval(refreshIntervalId);\r\n    //     clearInterval(refreshIntervalId);\r\n    // src.delete(); dst.delete(); //TODO delete also class Mat\r\n    // }\r\n\r\n\r\n}\r\n","import '../styles/index.scss';\r\nimport Maze from './Maze.js';\r\n\r\n\r\n\r\ndocument.getElementById('opencv').onload = () => {\r\n    cv['onRuntimeInitialized'] = () => {\r\n\r\n\r\n        let video = document.getElementById(\"video_input\");\r\n\r\n\r\n\r\n        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\r\n            console.log(\"enumerateDevices() not supported.\"); //TODO should be bug\r\n            return;\r\n        }\r\n\r\n        // List cameras and microphones.\r\n\r\n        let availableCameras = [];\r\n        let actualCameraIndex = 0;\r\n\r\n        let actualStream;\r\n\r\n\r\n\r\n        navigator.mediaDevices.enumerateDevices()\r\n            .then((devices) => {\r\n\r\n                // count cameras\r\n                devices.forEach((device) => {\r\n                    if (device.kind == 'videoinput') {\r\n                        availableCameras.push(device.deviceId);\r\n                    }\r\n                });\r\n\r\n                // add listener\r\n                document.getElementById('flip_camera_button').addEventListener(\"click\", () => {\r\n                    if (availableCameras.length > 1) {\r\n                        actualCameraIndex = actualCameraIndex == 1 ? 0 : 1;\r\n\r\n                        actualStream.getTracks().forEach(track => {\r\n                            track.stop();\r\n                        });\r\n\r\n                        navigator.mediaDevices.getUserMedia(constraints)\r\n                            .then(successCallback)\r\n                            .catch(errorCallback);\r\n\r\n                            document.getElementById('status').innerHTML = availableCameras[0] + '<br/>' + availableCameras[1];\r\n                            // document.getElementById('status').innerHTML = availableCameras.length;\r\n                    }\r\n                    console.log(actualStream);\r\n\r\n\r\n                });\r\n\r\n                //start first\r\n                navigator.mediaDevices.getUserMedia(constraints)\r\n                    .then(successCallback)\r\n                    .catch(errorCallback);\r\n\r\n            })\r\n            .catch((err) => {\r\n                console.log(err.name + \": \" + err.message);\r\n            });\r\n\r\n\r\n\r\n        let constraints = {\r\n            audio: false,\r\n            video: {\r\n                deviceId: {\r\n                    exact: availableCameras[actualCameraIndex]\r\n                }\r\n            }\r\n        };\r\n        // var video = document.querySelector(\"video\");\r\n\r\n        function successCallback(stream) {\r\n            actualStream = stream;\r\n            video.srcObject = stream;\r\n            video.play();\r\n\r\n            video.addEventListener('canplaythrough', () => {\r\n\r\n                const cnvs = [\r\n                    'video_input',\r\n                    'canvas_output_labirynth',\r\n                    'canvas_output_solved_path',\r\n                    'canvas_output_green_points'\r\n                ];\r\n\r\n                for (const cnv of cnvs) {\r\n                    document.getElementById(cnv).width = video.offsetWidth;\r\n                    document.getElementById(cnv).height = video.offsetHeight;\r\n                }\r\n\r\n                document.getElementById('container').style.width = video.offsetWidth + \"px\";\r\n                document.getElementById('container').style.height = video.offsetHeight + \"px\";\r\n\r\n                document.getElementById('panel').style.width = video.offsetWidth + \"px\";\r\n\r\n                const gui = [\r\n                    'container',\r\n                    'loading',\r\n                    'panel'\r\n                ];\r\n\r\n                for (const el of gui) {\r\n                    document.getElementById(el).classList += \" loaded\";\r\n                }\r\n\r\n                const maze = new Maze(video);\r\n                maze.start();\r\n            });\r\n        }\r\n\r\n        function errorCallback(error) {\r\n            console.log(\"navigator.getUserMedia error: \", error);\r\n        }\r\n\r\n        if (!navigator.mediaDevices) {\r\n\r\n            document.getElementById('status').innerHTML = \"navigator.mediaDevices is undefined\";\r\n        }\r\n\r\n        // navigator.mediaDevices.getUserMedia(constraints)\r\n        //     .then(successCallback)\r\n        //     .catch(errorCallback);\r\n\r\n\r\n    };\r\n};"],"sourceRoot":""}